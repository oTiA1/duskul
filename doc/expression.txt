expression.c の一部はちょっとややこしいので、簡単に説明しておきます。
ただし、この辺りのプログラムは今回の拡張要求には関係しませんので、
動作の概要だけ把握しておけばよいと思います。

-------

(1) static int precedence(token_t op)

この関数は、二項演算子を表すトークンを引数として、演算子の優先順位を返す。
数が大きいほど優先順位が高い（先に演算する）。


(2) expnode *expression(void)

構文規則を見ると、「式」は「項」と「二項演算子」の連続である。
この関数は、項に相当する構文木（expnodeによる木構造）を返す関数 term() を、
次のトークンが二項演算子である限り繰り返し呼び出す。
項の後に演算子が出現しなくなったら式の評価は終わり、式全体を表す木構造への
ポインタを関数の値として返す。


(3) 構造体 oppbody と関数 oppPutOperator()

この構造体は、配列opstack に演算子、配列precにその優先順位、配列nodestackに
項を表す木へのポインタを格納する。メンバnodindexはこれらの配列の末尾 + 1 を
表す。初期値（何も格納されていない時）は０。

関数oppPutOperator()は関数expression()から呼び出されるが、まず、
配列nodestackに新しい木が格納され、次に、対応する二項演算子とともに関数
oppPutOperator()が呼び出される。
この時、引数の演算子の優先順位が、すでに構造体に格納されている末尾の演算子の
優先順位よりも低いか等しい場合、構造体に格納されている末尾の２つの項を
１つの項にまとめる。構造体の中に、引数の演算子の優先順位よりも高いものが
存在する限り、同じ動作を繰り返す。
最後に、演算子と演算子を構造体に格納して終わり。

例を使って、この手順の意味について説明する。

今、a + b + c という数式があったとする。

まず、最初の項 a。

nodestack: a
  opstack:

最初の演算子 +。

nodestack: a
  opstack: +

２番目の項、b。

nodestack: a b
  opstack: +

ここで演算子 + を追加しようとするが、先行する演算子と優先順位が同じなので、
a と b を１つの項 (a + b) にまとめる。

nodestack: (a+b)
  opstack:

演算子 + を追加。

nodestack: (a+b)
  opstack: +

３番目の項、c。

nodestack: (a+b) c
  opstack: +

もう演算子はないので、oppPutOperator()は第２引数で０を渡され、(-1)という
優先順位の演算子があるように動作する。これは先行する演算子より低いので、
(a+b) と c を１つの項 ((a+b) + c) にまとめる。

nodestack: ((a+b)+c)
  opstack:

ダミーの演算子 0 が追加されるが、これは無視して良い。

nodestack: ((a+b)+c)
  opstack: ０

最終的に式 ((a+b)+c) が得られた。

同様に、同じ優先順位の演算子が連続する場合、例えば i * j * k * m * n は
((((i * j) * k) * m) * n) という構文木になる。

次に、 a + b * c の場合。
この場合、２番目の演算子の方が優先順位が高いので、(a + b) のようには
まとめない。

nodestack: a b
  opstack: +

ここで * を追加すると、

nodestack: a b
  opstack: + *

項 c を追加。

nodestack: a b c
  opstack: + *

この後、もう演算子はないので、(-1)という優先順位の演算子があるように
動作する。これは先行する演算子より低いので、末尾２つの項を１つにまとめる。

nodestack: a (b*c)
  opstack: +

さらに、+ も(-1)より優先順位が高いので、

nodestack: (a+(b*c))
  opstack: 

となる。
式がもし a + b * c + d だったとすると、最後の演算子 + が追加される直前、

nodestack: a (b*c)
  opstack: +

となっているが、+ は追加しようとする演算子と同じ優先順位なのでさらに

nodestack: (a+(b*c))
  opstack:

となり、

nodestack: (a+(b*c)) d
  opstack: +

から最終的に ((a+(b*c)) + d) が得られる。
一方、式がもし a + b * c / d だったとすると、演算子 / が追加される直前、

nodestack: a (b*c)
  opstack: +

となるが、/ の方が優先順位が高いので

nodestack: a (b*c) d
  opstack: + /

となり、式の終わりで

nodestack: a ((b*c)/d)
  opstack: +

から最終的に (a+((b*c)/d)) が得られる。


式が a > b + c * d だったとすると、演算子の優先順位が次第に高くなるため、
２つの項を１つにまとめる動作は起きず、

nodestack: a b c d
  opstack: > + *

となる。式の終わりではここから

nodestack: a b (c*d)
  opstack: > +

nodestack: a (b+(c*d))
  opstack: >

nodestack: (a>(b+(c*d)))
  opstack:

となる。
配列に次々に要素が入れられるのはこのような場合だけなので、配列は優先順位の
種類分だけの大きさがあればよい。

構造体oppbodyを関数expression()のローカル変数としているのは、複雑な式の解析で
関数expression()が再帰的に呼び出された場合にも、解析中の式の情報が保持できる
からである（term()の中からexpression()が呼ばれることがある）。


※ なお、特に何かの文献等を参考にして記述した訳ではないので、同等の知られた
アルゴリズムがあるのかもしれないが分からない。

※ Pascal言語では、演算子の優先順位は構文規則の段階で規定されている。つまり、
演算子の優先順位を変更するには構文規則を書き直す必要がある。Duskulでは
関数 precedence() の定義を変更するだけでよい。

