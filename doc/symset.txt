symset.c について

この部分はちょっとややこしいので解説しておきます。

まず、型 symset_t はビット列を使って「集合」を表現しています。
集合の要素は token_t 型（enum token型）の値です。
構文解析の途中で、「この箇所には○と△のトークンだけが出現してもよい」という条件を
使いたい場合があります。if文で書いてもいいのですが、やたらと面倒になる場合もあります。
また、そのような条件が文脈によって変化することがあります。例えば、「文列」の最後に
end が現れるのは普通ですが、 if文の場合には else や elsif が現れることもあります。
そのような場合、「この箇所には集合の要素に含まれるトークンだけが出現してもよい」
と書くことができると大変コンパクトに実装できます。

enum token型は token.h で定義されているように結構たくさんの要素が定義されています。
言語仕様を拡張するとさらに個数が増えるかもしれません。
個数が増えたとしても、最後の要素を total_num_of_symbols にしておくと、この定数が
enum token型に含まれる要素の総数を表現します。
（同様に、途中にある combined_symbol_0, reserved_word_0, all_normal_symbols も
トークンを表すのではなく、そこまでいくつあるかという「目印」です。少しトリッキー）

この enum token型は列挙型なので結局整数ですが、これを集合として簡単かつ高速に表現
するためにビット演算を使います。
symset.h に型 symset_t の定義がありますが、構造体の中身は unsigned long の配列です。
マクロ BITS_IN_WORD は unsigned long に含まれるビット数、WORDS_OF_SYMSETは、
all_normal_symbols個のビットを含めるために必要な unsigned long の個数になります。
現在の実装では all_normal_symbolsが 64以下だと思われるので、WORDS_OF_SYMSETは 1 に
なっていますが、２以上でも動作するように記述してあります。
さらに、symset_t型が配列そのものではなく、構造体になっているのにも理由があります。
C言語では配列全体を代入文でコピーできませんが、構造体の要素ならば可能だからです。
代入だけではなく、関数の引数として使うこともできます。

まず関数 symsetCreate() は、token_t型の配列に入れられた要素を、ビット列の表現に
変更します。引数の配列の最後には tok_EOD という定数がある約束になっています。
関数 symInitialize() は主な集合をあらかじめ設定しておくためのものです。
集合の設定には関数 symsetCreate() を使いますが、その引数には配列を与えるのでした。
配列を（普通に定義して）用意してもいいのですが、この呼び出しでしか使わないため、
ここではC言語の新しい規格 C99 で決められた書き方を使っています。この書き方を使うと、
その場所に書き並べられた値を要素とする配列を一時的に構成することができます。
例えば、

    prefix_set = symsetCreate((token_t[]){
        sym_plus, sym_minus, sym_not, tok_EOD }
    );

とあるのは、

    static token_t temp[] = { sym_plus, sym_minus, sym_not, tok_EOD };
    prefix_set = symsetCreate(temp);

とするのと同じです。
関数 symsetUnion() は、引数 a と引数 b の表す集合の和集合を、新たに a の値にします。
関数 symsetAdd() は、第１引数の集合に、第２引数の要素を追加します。
関数 symsetHas() は、第１引数の集合に、第２引数の要素が含まれているかを調べます。

以上。
